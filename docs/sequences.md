# Factory Methods

Factory methods to create an iterable sequence from something else.

## Usage

The simplest way to import all the factory methods is to use the full package.

```javascript
import { sequences } from 'iterablefu'
console.log(...sequences.range(5)) // prints 0 1 2 3 4
```

To minimize dependencies to support tree-shaking, import individual functions.

```javascript
import { range } from './src/sequences.js'
console.log(...range(5)) // prints 0 1 2 3 4
```

## Table of Contents


<!-- !toc (level=2 minlevel=2 omit="Usage;Table of Contents") -->

* [concatenate](#concatenate)
* [from](#from)
* [range](#range)
* [repeat](#repeat)
* [repeatIterable](#repeatiterable)
* [zip](#zip)
* [zipAll](#zipall)

<!-- toc! -->

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

## concatenate

Concatenates a list of iterables into a single iterable.

### Parameters

- `iterables` **...Iterable** to be concatenated

### Examples

```javascript
const generator = concatenate([0, 1, 2], [3, 4])
console.log([...generator]) // prints [0, 1, 2, 3, 4]
```

Returns **Generator** that provides the output of each iterable in turn

## from

Creates a sequence from the input sequence. This function exists solely
so that ChainableIterable has a static constructor method.

### Parameters

- `iterable`  
- `inputIterable` **Iterable** the iterable

### Examples

```javascript
const generatorFunction = function * (n) {
  for (let i = 0; i < n; i++) {
    yield i
  }
}
const generator = from(generatorFunction(3))
console.log([...generator]) // prints [0, 1, 2]
```

Returns **Generator** that represents the same iterable that was passed in

## range

Creates a sequence of numbers similar to the Python range. See the example.

### Parameters

- `args` **...integer** per the example

### Examples

```javascript
console.log([...range()]) // prints []

console.log([...range(5)]) // prints [0, 1, 2, 3, 4]

console.log([...range(2, 5)]) // prints [2, 3, 4, 5, 6]

console.log([...range(2, 5, 3)] // prints [2, 5, 8, 11, 14]
```

Returns **Generator** that represents the range

## repeat

Generates a sequence of things, n times

### Parameters

- `n` **[number][1]** the number of times to repeat thing
- `thing` **any** the repeated thing

### Examples

```javascript
const generator = repeat(5, 'a')
console.log([...generator]) // prints ['a', 'a', 'a', 'a', 'a']
```

Returns **Generator** that will repeat thing, n times

## repeatIterable

Repeat an iterable n times.

NOTE: Generator functions are designed to create one-time-use iterables, and will not work as expected
with repeatIterable. Once a generator completes, it won't restart, and therefore can't be repeated.

Instead, use an iterable object where calling [Symbol.iterator] returns a new Generator object with
new state. See the examples below...

### Parameters

- `n` **[number][1]** number of times to repeat iterable
- `iterable` **Iterable** the input iterable to repeat, soe notes above and example.

### Examples

```javascript
// As noted above, use iterable objects, not generator functions with repeatIterable
const fn = (length) => {
  return {
    * [Symbol.iterator] () {
      for (let i = 0; i < length; i++) {
        yield i
      }
    }
  }
}
const a = repeatIterable(3, fn(3))
console.log([...a]) // prints [0, 1, 2, 0, 1, 2, 0, 1, 2] as expected
```

```javascript
// NOTE: This generator function will not work as expected with repeatIterable.
const oneTime = function * (length) {
  for (let i = 0; i < length; i++) {
    yield i
  }
}
const a = repeatIterable(3, oneTime(3))
console.log([...a]) // prints [0, 1, 2] OOPS!!!!
```

Returns **Generator** that will repeat the input iterable n times

## zip

Creates a sequence of arrays the same length as the _shortest_ iterable provided. The first array contains the first
element from each of the iterables provided. The second array contains the second element from each of the
iterables provided, and so on.

### Parameters

- `iterables` **...Iterable** the iterables to be zipped

### Examples

```javascript
const a = [0, 1, 2]
const b = ['a', 'b', 'c', 'd', 'e', 'f'] // note that this array is longer than a
const generator = zip(a, b)
console.log([...generator]) // prints [[0, 'a'], [1, 'b'], [2, 'c']]
```

Returns **Generator** for the zipped arrays

## zipAll

Creates a sequence of arrays the same length as the _longest_ iterable provided. The first array contains the first
element from each of the iterables provided. The second array contains the second element from each of the
iterables provided, and so on. Missing elements from the shorter iterables are set to undefined.

### Parameters

- `iterables` **...Iterable** the iterables to be zipped

### Examples

```javascript
const a = [0, 1, 2]
const b = ['a', 'b', 'c', 'd'] // note that this array is longer than a
const generator = zipAll(a, b)
console.log([...generator]) // prints [[0, 'a'], [1, 'b'], [2, 'c'], [undefined, 'd']]
```

Returns **Generator** for the zipped arrays

[1]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number
